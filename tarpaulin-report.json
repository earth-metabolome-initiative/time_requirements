{"files":[{"path":["/","home","lucac","github","time_requirements","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\n\npub mod report;\npub mod task;\npub mod time_tracker;\n\n/// Prelude module to re-export commonly used items.\npub mod prelude {\n    pub use crate::{report::Report, task::Task, time_tracker::TimeTracker};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","time_requirements","src","report.rs"],"content":"//! Submodule defining the structs and methods for generating a report.\n\nuse std::{io::Write, path::Path};\n\nuse chrono_humanize::{Accuracy, HumanTime, Tense};\nuse tabled::{Table, Tabled, settings::Style};\n\nuse crate::{prelude::TimeTracker, task::CompletedTask};\n\n/// A report for a time tracker.\npub struct Report {\n    /// The time tracker to generate a report for.\n    time_tracker: TimeTracker,\n}\n\n#[derive(Tabled)]\nstruct TableRow<'a> {\n    name: &'a str,\n    time: String,\n    percentage: String,\n}\n\nimpl Report {\n    fn title(&self, depth: usize) -> String {\n        format!(\"{} Time Report for {}\\n\\n\", \"#\".repeat(depth + 1), self.time_tracker.name())\n    }\n\n    fn description(&self) -> String {\n        let total_time = self.time_tracker.total_time();\n\n        format!(\n            \"The total time spent on all tasks was {}.\\n\",\n            HumanTime::from(total_time).to_text_en(Accuracy::Rough, Tense::Present),\n        )\n    }\n\n    #[allow(clippy::cast_precision_loss)]\n    fn slowest_task_description(&self) -> Option<String> {\n        self.time_tracker.slowest_task().map(|task| {\n            let total_time = self.time_tracker.total_time();\n            format!(\n                \"The slowest task was `{}` which took {} ({:.2}% of all time).\",\n                task.name(),\n                HumanTime::from(task.time()).to_text_en(Accuracy::Precise, Tense::Present),\n                task.precise_percentage_over(total_time),\n            )\n        })\n    }\n\n    #[must_use]\n    /// Slowest task in the report\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{thread, time::Duration};\n    ///\n    /// use time_requirements::prelude::*;\n    ///\n    /// // No tasks\n    /// let tracker = TimeTracker::new(\"Project\");\n    /// let report: Report = tracker.into();\n    /// assert!(report.slowest_task().is_none());\n    ///\n    /// // One task\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    /// let task = Task::new(\"Only task\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// tracker.add_completed_task(task);\n    /// let report: Report = tracker.into();\n    /// assert_eq!(report.slowest_task().unwrap().name(), \"Only task\");\n    ///\n    /// // Multiple tasks\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    /// let task1 = Task::new(\"Short task\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// tracker.add_completed_task(task1);\n    ///\n    /// let task2 = Task::new(\"Long task\");\n    /// thread::sleep(Duration::from_millis(100));\n    /// tracker.add_completed_task(task2);\n    ///\n    /// let report: Report = tracker.into();\n    /// assert_eq!(report.slowest_task().unwrap().name(), \"Long task\");\n    /// ```\n    pub fn slowest_task(&self) -> Option<&CompletedTask> {\n        self.time_tracker.slowest_task()\n    }\n\n    /// Returns an iterator over the sub-reports.\n    fn sub_reports(&self) -> impl Iterator<Item = Report> + '_ {\n        self.time_tracker.sub_trackers().iter().cloned().map(|time_tracker| Self { time_tracker })\n    }\n\n    #[allow(clippy::cast_precision_loss)]\n    /// Returns the text of the report.\n    fn text(&self, depth: usize) -> String {\n        let total_time = self.time_tracker.total_time();\n        let rows = self.time_tracker.tasks().map(|task| {\n            TableRow {\n                name: task.name(),\n                time: HumanTime::from(task.time()).to_text_en(Accuracy::Precise, Tense::Present),\n                percentage: format!(\"{:.2}%\", task.precise_percentage_over(total_time)),\n            }\n        });\n        let mut table = Table::new(rows);\n        table.with(Style::markdown());\n\n        let mut report = String::new();\n\n        report.push_str(&self.title(depth));\n        report.push_str(&self.description());\n\n        if let Some(description) = self.slowest_task_description() {\n            report.push_str(&description);\n        }\n\n        report.push_str(\"\\n\\n\");\n        report.push_str(&table.to_string());\n\n        for sub_report in self.sub_reports() {\n            report.push_str(\"\\n\\n\");\n            report.push_str(&sub_report.text((depth + 1).min(6)));\n        }\n\n        report\n    }\n\n    /// Writes out the markdown report to a given file.\n    ///\n    /// # Arguments\n    ///\n    /// * `report_path` - The path to the file to write the report to.\n    ///\n    /// # Errors\n    ///\n    /// If the file cannot be created or written to, an error will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{path::Path, thread, time::Duration};\n    ///\n    /// use time_requirements::prelude::*;\n    ///\n    /// // Create current tracker with tasks and sub-tracker\n    /// let mut current_tracker = TimeTracker::new(\"Current Project\");\n    /// let task = Task::new(\"Main Task\");\n    /// thread::sleep(Duration::from_millis(100));\n    /// current_tracker.add_completed_task(task);\n    ///\n    /// // Add a sub-tracker\n    /// let sub_tracker = TimeTracker::new(\"Sub Project\");\n    /// current_tracker.extend(sub_tracker);\n    ///\n    /// // Create previous tracker with same task time\n    /// let mut previous_tracker = TimeTracker::new(\"Previous Project\");\n    /// let prev_task = Task::new(\"Main Task\");\n    /// thread::sleep(Duration::from_millis(100)); // Same time\n    /// previous_tracker.add_completed_task(prev_task);\n    ///\n    /// let mut report: Report = current_tracker.into();\n    ///\n    /// let temp_path = std::env::temp_dir().join(\"test_report.md\");\n    /// report.write(&temp_path).expect(\"Failed to write report\");\n    /// assert!(temp_path.exists());\n    /// std::fs::remove_file(temp_path).ok(); // Clean up\n    /// ```\n    pub fn write<S: AsRef<Path> + ?Sized>(&self, report_path: &S) -> std::io::Result<()> {\n        let mut file = std::fs::File::create(report_path)?;\n\n        writeln!(file, \"{}\", self.text(0))?;\n\n        Ok(())\n    }\n}\n\nimpl From<TimeTracker> for Report {\n    /// Creates a new report from a time tracker.\n    fn from(time_tracker: TimeTracker) -> Self {\n        Self { time_tracker }\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":36}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":29,"address":[],"length":0,"stats":{"Line":18}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":30}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":22}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":8}},{"line":44,"address":[],"length":0,"stats":{"Line":24}},{"line":45,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":30}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":18}},{"line":99,"address":[],"length":0,"stats":{"Line":31}},{"line":100,"address":[],"length":0,"stats":{"Line":7}},{"line":101,"address":[],"length":0,"stats":{"Line":14}},{"line":102,"address":[],"length":0,"stats":{"Line":49}},{"line":103,"address":[],"length":0,"stats":{"Line":21}},{"line":106,"address":[],"length":0,"stats":{"Line":18}},{"line":107,"address":[],"length":0,"stats":{"Line":18}},{"line":109,"address":[],"length":0,"stats":{"Line":12}},{"line":111,"address":[],"length":0,"stats":{"Line":24}},{"line":112,"address":[],"length":0,"stats":{"Line":18}},{"line":114,"address":[],"length":0,"stats":{"Line":14}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":118,"address":[],"length":0,"stats":{"Line":18}},{"line":119,"address":[],"length":0,"stats":{"Line":18}},{"line":121,"address":[],"length":0,"stats":{"Line":18}},{"line":122,"address":[],"length":0,"stats":{"Line":12}},{"line":123,"address":[],"length":0,"stats":{"Line":15}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":9}},{"line":172,"address":[],"length":0,"stats":{"Line":12}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":6}}],"covered":42,"coverable":42},{"path":["/","home","lucac","github","time_requirements","src","task.rs"],"content":"//! Submodule defining a task to be tracked.\n\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Hash)]\n/// A task to be tracked.\npub struct Task {\n    /// The name of the task.\n    name: String,\n    /// The start time of the task.\n    start: chrono::NaiveDateTime,\n}\n\nimpl Task {\n    /// Create a new task with the given name.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::task::Task;\n    ///\n    /// let task = Task::new(\"My Task\");\n    /// assert_eq!(task.name(), \"My Task\");\n    ///\n    /// // Using From trait\n    /// let task2: Task = \"My Task\".into();\n    /// assert_eq!(task2.name(), \"My Task\");\n    ///\n    /// let task3: Task = String::from(\"My Task\").into();\n    /// assert_eq!(task3.name(), \"My Task\");\n    /// ```\n    pub fn new<S: ToString + ?Sized>(name: &S) -> Self {\n        Self { name: name.to_string(), start: chrono::Local::now().naive_local() }\n    }\n\n    /// Returns the name of the task.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::task::Task;\n    ///\n    /// let task = Task::new(\"My Task\");\n    /// assert_eq!(task.name(), \"My Task\");\n    /// ```\n    #[must_use]\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    #[must_use]\n    /// Marks the task as completed.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::task::Task;\n    ///\n    /// let task = Task::new(\"My Task\");\n    /// let completed = task.complete();\n    /// assert_eq!(completed.name(), \"My Task\");\n    /// ```\n    pub fn complete(self) -> CompletedTask {\n        CompletedTask {\n            name: self.name,\n            start: self.start,\n            end: chrono::Local::now().naive_local(),\n        }\n    }\n}\n\nimpl From<&str> for Task {\n    fn from(name: &str) -> Self {\n        Self::new(name)\n    }\n}\n\nimpl From<String> for Task {\n    fn from(name: String) -> Self {\n        Self::new(&name)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Hash)]\n/// A completed task.\npub struct CompletedTask {\n    /// The name of the task.\n    pub(crate) name: String,\n    /// The start time of the task.\n    pub(crate) start: chrono::NaiveDateTime,\n    /// The end time of the task.\n    pub(crate) end: chrono::NaiveDateTime,\n}\n\nimpl CompletedTask {\n    #[must_use]\n    /// Returns the name of the task.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::task::Task;\n    ///\n    /// let task = Task::new(\"My Task\");\n    /// let completed = task.complete();\n    /// assert_eq!(completed.name(), \"My Task\");\n    /// ```\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    #[must_use]\n    /// Returns the time required to complete the task.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{thread, time::Duration};\n    ///\n    /// use time_requirements::task::Task;\n    ///\n    /// let task = Task::new(\"My Task\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// let completed = task.complete();\n    /// let time = completed.time();\n    /// assert!(time.num_milliseconds() >= 10);\n    /// assert!(time.num_milliseconds() > 0);\n    /// ```\n    pub fn time(&self) -> chrono::TimeDelta {\n        self.end - self.start\n    }\n\n    /// Extends the completed task by another completed task.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{thread, time::Duration};\n    ///\n    /// use time_requirements::task::Task;\n    ///\n    /// let task1 = Task::new(\"Task 1\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// let mut completed1 = task1.complete();\n    /// let original_time = completed1.time();\n    ///\n    /// let task2 = Task::new(\"Task 2\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// let completed2 = task2.complete();\n    /// completed1.extend(&completed2);\n    /// assert!(completed1.time() > original_time);\n    ///\n    /// // Extend again\n    /// let task3 = Task::new(\"Task 3\");\n    /// thread::sleep(Duration::from_millis(5));\n    /// let completed3 = task3.complete();\n    /// let before_second_extend = completed1.time();\n    /// completed1.extend(&completed3);\n    /// assert!(completed1.time() > before_second_extend);\n    ///\n    /// // Comparison using PartialOrd\n    /// assert!(completed2 > completed3); // completed2 took longer\n    /// ```\n    pub fn extend(&mut self, other: &CompletedTask) {\n        self.end += other.time();\n    }\n\n    /// Returns the most precise percentage over the provided `TimeDelta`.\n    ///\n    /// # Arguments\n    ///\n    /// * `total_time` - The total time to calculate the percentage over.\n    ///\n    /// # Implementation Note\n    ///\n    /// This methods attempts to use the most precise method available to\n    /// calculate the percentage. It first tries to use nanoseconds, then\n    /// microseconds, then milliseconds, and finally seconds, depending on\n    /// whether the conversion is lossless.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{thread, time::Duration};\n    ///\n    /// use chrono::TimeDelta;\n    /// use time_requirements::task::Task;\n    ///\n    /// let task = Task::new(\"Task\");\n    /// thread::sleep(Duration::from_millis(100));\n    /// let completed = task.complete();\n    ///\n    /// // Total time larger than task time\n    /// let total_time = TimeDelta::milliseconds(200);\n    /// let percentage = completed.precise_percentage_over(total_time);\n    /// assert!(percentage > 40.0 && percentage < 60.0);\n    ///\n    /// // Total time equal to task time\n    /// let total_time = completed.time();\n    /// let percentage = completed.precise_percentage_over(total_time);\n    /// assert!((percentage - 100.0).abs() < 0.01);\n    ///\n    /// // Total time smaller than task time\n    /// let total_time = TimeDelta::milliseconds(50);\n    /// let percentage = completed.precise_percentage_over(total_time);\n    /// assert!(percentage > 100.0);\n    /// ```\n    #[must_use]\n    #[allow(clippy::cast_precision_loss)]\n    pub fn precise_percentage_over(&self, total_time: chrono::TimeDelta) -> f64 {\n        if let Some(micros) = self.time().num_microseconds()\n            && let Some(total_micros) = total_time.num_microseconds()\n        {\n            return micros as f64 / total_micros as f64 * 100.0;\n        }\n        self.time().num_milliseconds() as f64 / total_time.num_milliseconds() as f64 * 100.0\n    }\n}\n\nimpl From<Task> for CompletedTask {\n    fn from(task: Task) -> Self {\n        task.complete()\n    }\n}\n\nimpl Ord for CompletedTask {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.time().cmp(&other.time())\n    }\n}\n\nimpl PartialOrd for CompletedTask {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":33}},{"line":31,"address":[],"length":0,"stats":{"Line":99}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":61,"address":[],"length":0,"stats":{"Line":29}},{"line":63,"address":[],"length":0,"stats":{"Line":58}},{"line":64,"address":[],"length":0,"stats":{"Line":58}},{"line":65,"address":[],"length":0,"stats":{"Line":29}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":21}},{"line":107,"address":[],"length":0,"stats":{"Line":21}},{"line":127,"address":[],"length":0,"stats":{"Line":70}},{"line":128,"address":[],"length":0,"stats":{"Line":70}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":163,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":14}},{"line":209,"address":[],"length":0,"stats":{"Line":28}},{"line":210,"address":[],"length":0,"stats":{"Line":28}},{"line":212,"address":[],"length":0,"stats":{"Line":14}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":22}},{"line":220,"address":[],"length":0,"stats":{"Line":44}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":226,"address":[],"length":0,"stats":{"Line":18}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":2}}],"covered":28,"coverable":29},{"path":["/","home","lucac","github","time_requirements","src","time_tracker.rs"],"content":"//! Submodule defining the task tracker.\n\nuse std::path::Path;\n\nuse crate::{\n    report::Report,\n    task::{CompletedTask, Task},\n};\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n/// A tracker for tasks.\npub struct TimeTracker {\n    /// Name of the overall project.\n    name: String,\n    /// The tasks being tracked.\n    tasks: Vec<CompletedTask>,\n    /// The sub-trackers being tracked.\n    sub_trackers: Vec<TimeTracker>,\n    /// Start of the project.\n    start: chrono::NaiveDateTime,\n}\n\nimpl TimeTracker {\n    /// Creates a new time tracker for the given project name.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::time_tracker::TimeTracker;\n    ///\n    /// let tracker = TimeTracker::new(\"My Project\");\n    /// assert_eq!(tracker.name(), \"My Project\");\n    /// ```\n    pub fn new<S: ToString + ?Sized>(name: &S) -> Self {\n        Self {\n            name: name.to_string(),\n            tasks: Vec::new(),\n            sub_trackers: Vec::new(),\n            start: chrono::Local::now().naive_local(),\n        }\n    }\n\n    /// Returns the sub-trackers.\n    pub(crate) fn sub_trackers(&self) -> &[TimeTracker] {\n        &self.sub_trackers\n    }\n\n    /// Extends the tracker from another tracker.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::{task::Task, time_tracker::TimeTracker};\n    ///\n    /// let mut tracker1 = TimeTracker::new(\"Project 1\");\n    /// let task = Task::new(\"Task\");\n    /// tracker1.add_completed_task(task);\n    /// let initial_tasks = tracker1.tasks().count();\n    ///\n    /// let tracker2 = TimeTracker::new(\"Project 2\");\n    /// tracker1.extend(tracker2);\n    /// assert_eq!(tracker1.tasks().count(), initial_tasks + 1); // Adds to_completed_task of tracker2\n    /// ```\n    pub fn extend(&mut self, other: TimeTracker) {\n        self.tasks.push(other.clone().into());\n        self.sub_trackers.push(other);\n    }\n\n    /// Adds a task to the tracker.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::{task::Task, time_tracker::TimeTracker};\n    ///\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    /// assert_eq!(tracker.tasks().count(), 0);\n    ///\n    /// let task1 = Task::new(\"Task 1\");\n    /// tracker.add_completed_task(task1);\n    /// assert_eq!(tracker.tasks().count(), 1);\n    ///\n    /// let task2 = Task::new(\"Task 2\");\n    /// tracker.add_completed_task(task2);\n    /// assert_eq!(tracker.tasks().count(), 2);\n    /// ```\n    pub fn add_completed_task(&mut self, task: Task) {\n        self.tasks.push(task.into());\n    }\n\n    /// Extends a previously completed task.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{thread, time::Duration};\n    ///\n    /// use time_requirements::{task::Task, time_tracker::TimeTracker};\n    ///\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    ///\n    /// // Add new task\n    /// let task1 = Task::new(\"Task\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// tracker.add_or_extend_completed_task(task1);\n    /// assert_eq!(tracker.tasks().count(), 1);\n    ///\n    /// // Extend existing task\n    /// let task2 = Task::new(\"Task\"); // Same name\n    /// thread::sleep(Duration::from_millis(10));\n    /// tracker.add_or_extend_completed_task(task2);\n    /// assert_eq!(tracker.tasks().count(), 1); // Still one task, but extended\n    ///\n    /// // Add another new task\n    /// let task3 = Task::new(\"Another Task\");\n    /// tracker.add_or_extend_completed_task(task3);\n    /// assert_eq!(tracker.tasks().count(), 2);\n    /// ```\n    pub fn add_or_extend_completed_task(&mut self, task: Task) {\n        for existing_task in &mut self.tasks {\n            if existing_task.name() == task.name() {\n                existing_task.extend(&task.into());\n                return;\n            }\n        }\n        self.tasks.push(task.into());\n    }\n\n    #[must_use]\n    /// Returns the name of the project.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::time_tracker::TimeTracker;\n    ///\n    /// let tracker = TimeTracker::new(\"My Project\");\n    /// assert_eq!(tracker.name(), \"My Project\");\n    /// ```\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    #[must_use]\n    /// Returns the start time of the project.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::time_tracker::TimeTracker;\n    ///\n    /// let tracker = TimeTracker::new(\"Project\");\n    /// let start_time = tracker.start();\n    /// // start_time is a NaiveDateTime\n    /// ```\n    pub fn start(&self) -> chrono::NaiveDateTime {\n        self.start\n    }\n\n    /// Iterates the task from the tracker.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use time_requirements::{task::Task, time_tracker::TimeTracker};\n    ///\n    /// // Empty tracker\n    /// let tracker = TimeTracker::new(\"Project\");\n    /// let tasks: Vec<_> = tracker.tasks().collect();\n    /// assert!(tasks.is_empty());\n    ///\n    /// // Tracker with tasks\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    /// let task1 = Task::new(\"Task 1\");\n    /// let task2 = Task::new(\"Task 2\");\n    /// tracker.add_completed_task(task1);\n    /// tracker.add_completed_task(task2);\n    ///\n    /// let tasks: Vec<_> = tracker.tasks().collect();\n    /// assert_eq!(tasks.len(), 2);\n    /// assert_eq!(tasks[0].name(), \"Task 1\");\n    /// assert_eq!(tasks[1].name(), \"Task 2\");\n    /// ```\n    pub fn tasks(&self) -> impl Iterator<Item = &CompletedTask> {\n        self.tasks.iter()\n    }\n\n    #[must_use]\n    /// Returns a reference to the slowest task.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{thread, time::Duration};\n    ///\n    /// use time_requirements::{task::Task, time_tracker::TimeTracker};\n    ///\n    /// // No tasks\n    /// let tracker = TimeTracker::new(\"Project\");\n    /// assert!(tracker.slowest_task().is_none());\n    ///\n    /// // One task\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    /// let task = Task::new(\"Only task\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// tracker.add_completed_task(task);\n    /// assert_eq!(tracker.slowest_task().unwrap().name(), \"Only task\");\n    ///\n    /// // Multiple tasks\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    /// let task1 = Task::new(\"Short\");\n    /// thread::sleep(Duration::from_millis(10));\n    /// tracker.add_completed_task(task1);\n    ///\n    /// let task2 = Task::new(\"Long\");\n    /// thread::sleep(Duration::from_millis(100));\n    /// tracker.add_completed_task(task2);\n    ///\n    /// assert_eq!(tracker.slowest_task().unwrap().name(), \"Long\");\n    /// ```\n    pub fn slowest_task(&self) -> Option<&CompletedTask> {\n        self.tasks.iter().max()\n    }\n\n    #[must_use]\n    /// Returns the total amount of time spent on all tasks.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::{thread, time::Duration};\n    ///\n    /// use time_requirements::{task::Task, time_tracker::TimeTracker};\n    ///\n    /// // Empty tracker\n    /// let tracker = TimeTracker::new(\"Project\");\n    /// assert_eq!(tracker.total_time().num_milliseconds(), 0);\n    ///\n    /// // Tracker with tasks\n    /// let mut tracker = TimeTracker::new(\"Project\");\n    /// let task1 = Task::new(\"Task 1\");\n    /// thread::sleep(Duration::from_millis(50));\n    /// tracker.add_completed_task(task1);\n    ///\n    /// let task2 = Task::new(\"Task 2\");\n    /// thread::sleep(Duration::from_millis(30));\n    /// tracker.add_completed_task(task2);\n    ///\n    /// let total = tracker.total_time();\n    /// assert!(total.num_milliseconds() >= 80); // At least 80ms\n    /// ```\n    pub fn total_time(&self) -> chrono::TimeDelta {\n        self.tasks.iter().map(CompletedTask::time).sum()\n    }\n\n    /// Saves the report as a JSON in the provided directory.\n    ///\n    /// # Arguments\n    ///\n    /// * `directory` - The directory to save the report in.\n    ///\n    /// # Errors\n    ///\n    /// If the directory does not exist or is not writable, an error will be\n    /// returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// use time_requirements::time_tracker::TimeTracker;\n    ///\n    /// let tracker = TimeTracker::new(\"Project\");\n    /// let temp_dir = std::env::temp_dir();\n    /// tracker.save(&temp_dir).expect(\"Failed to save\");\n    /// let file_path = temp_dir.join(\"Project.json\");\n    /// assert!(file_path.exists());\n    /// std::fs::remove_file(file_path).ok(); // Clean up\n    /// ```\n    pub fn save(&self, directory: &std::path::Path) -> std::io::Result<()> {\n        let file = std::fs::File::create(directory.join(format!(\"{}.json\", self.name)))?;\n        serde_json::to_writer(file, self)?;\n        Ok(())\n    }\n\n    /// Writes out the markdown report to a given file.\n    ///\n    /// # Arguments\n    ///\n    /// * `report_path` - The path to the file to write the report to.\n    ///\n    /// # Errors\n    ///\n    /// If the file cannot be created or written to, an error will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::{path::Path, thread, time::Duration};\n    ///\n    /// use time_requirements::prelude::*;\n    ///\n    /// // Create current tracker with tasks and sub-tracker\n    /// let mut current_tracker = TimeTracker::new(\"Current Project\");\n    /// let task = Task::new(\"Main Task\");\n    /// thread::sleep(Duration::from_millis(100));\n    /// current_tracker.add_completed_task(task);\n    ///\n    /// // Add a sub-tracker\n    /// let sub_tracker = TimeTracker::new(\"Sub Project\");\n    /// current_tracker.extend(sub_tracker);\n    ///\n    /// // Create previous tracker with same task time\n    /// let mut previous_tracker = TimeTracker::new(\"Previous Project\");\n    /// let prev_task = Task::new(\"Main Task\");\n    /// thread::sleep(Duration::from_millis(100)); // Same time\n    /// previous_tracker.add_completed_task(prev_task);\n    ///\n    /// let temp_path = std::env::temp_dir().join(\"test_report.md\");\n    /// current_tracker.write(&temp_path).expect(\"Failed to write report\");\n    /// assert!(temp_path.exists());\n    /// std::fs::remove_file(temp_path).ok(); // Clean up\n    /// ```\n    pub fn write<S: AsRef<Path> + ?Sized>(&self, report_path: &S) -> std::io::Result<()> {\n        let report: Report = self.clone().into();\n        report.write(report_path)?;\n\n        Ok(())\n    }\n}\n\nimpl From<TimeTracker> for CompletedTask {\n    fn from(tracker: TimeTracker) -> Self {\n        CompletedTask {\n            name: tracker.name.clone(),\n            start: tracker.start,\n            end: tracker.start + tracker.total_time(),\n        }\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":26}},{"line":36,"address":[],"length":0,"stats":{"Line":78}},{"line":37,"address":[],"length":0,"stats":{"Line":52}},{"line":38,"address":[],"length":0,"stats":{"Line":52}},{"line":39,"address":[],"length":0,"stats":{"Line":26}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":20}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":87,"address":[],"length":0,"stats":{"Line":19}},{"line":88,"address":[],"length":0,"stats":{"Line":76}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":140,"address":[],"length":0,"stats":{"Line":8}},{"line":141,"address":[],"length":0,"stats":{"Line":8}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":16}},{"line":185,"address":[],"length":0,"stats":{"Line":16}},{"line":221,"address":[],"length":0,"stats":{"Line":12}},{"line":222,"address":[],"length":0,"stats":{"Line":24}},{"line":252,"address":[],"length":0,"stats":{"Line":22}},{"line":253,"address":[],"length":0,"stats":{"Line":66}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":5}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[],"length":0,"stats":{"Line":10}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":329,"address":[],"length":0,"stats":{"Line":2}},{"line":334,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":12}},{"line":337,"address":[],"length":0,"stats":{"Line":8}},{"line":338,"address":[],"length":0,"stats":{"Line":8}}],"covered":40,"coverable":40},{"path":["/","home","lucac","github","time_requirements","tests","test_time_requirements.rs"],"content":"//! Submodule defining the task tracker.\nuse time_requirements::prelude::*;\n\n/// Generate a time tracker for testing.\n#[must_use]\npub fn time_tracker() -> TimeTracker {\n    let mut tracker = TimeTracker::new(\"Test Project\");\n\n    let task1 = Task::new(\"Test Task 1\");\n    // We sleep for 1 second to simulate the task taking time.\n    std::thread::sleep(std::time::Duration::from_secs(1));\n    tracker.add_completed_task(task1);\n\n    // We add a second task\n    let task2 = Task::new(\"Test Task 2\");\n    // We sleep for 2 seconds to simulate the task taking time.\n    std::thread::sleep(std::time::Duration::from_secs(2));\n    tracker.add_completed_task(task2);\n\n    tracker\n}\n\n#[test]\n/// Test the time requirements.\npub fn test_time_requirements() {\n    let tracker = time_tracker();\n\n    assert_eq!(tracker.name(), \"Test Project\");\n    assert_eq!(tracker.tasks().count(), 2);\n\n    let task1 = tracker.tasks().next().unwrap();\n    assert_eq!(task1.name(), \"Test Task 1\");\n    assert_eq!(task1.time().num_seconds(), 1);\n\n    let task2 = tracker.tasks().nth(1).unwrap();\n    assert_eq!(task2.name(), \"Test Task 2\");\n    assert_eq!(task2.time().num_seconds(), 2);\n\n    assert_eq!(tracker.total_time().num_seconds(), 3);\n    assert_eq!(tracker.slowest_task().unwrap().name(), \"Test Task 2\");\n    assert_eq!(tracker.slowest_task().unwrap().time().num_seconds(), 2);\n}\n\n#[test]\n/// Test the time report generation.\npub fn test_time_report() {\n    use std::path::Path;\n\n    let tracker = time_tracker();\n    tracker.write(Path::new(\"time_report.md\")).unwrap();\n\n    // Clean up the generated report\n    std::fs::remove_file(\"time_report.md\").unwrap();\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":99.09909909909909,"covered":110,"coverable":111}